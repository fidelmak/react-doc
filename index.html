<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentation</title>
    <link rel="stylesheet" href="reactDocs.css">
</head>
<body>

    
<nav id="navbar">
    <header> <img id='header-img' src='logo.ico' width="20" height="20"> Reactjs</header>
    
    <ul>
      <li><a class="nav-link" href="#Helloworld">Hello World</a></li>
      <li>
        <a class="nav-link" href="#IntroducingJsx"
          >Introduction to Jsx</a
        >
      </li>
      <li>
        <a class="nav-link" href="#RenderingElements">Rendering Elements</a>
      </li>
      <li><a class="nav-link" href="#components_and_props">Components and props </a></li>
      <li>
        <a class="nav-link" href="#State_and_life_cycle">State and Life Cycle</a>
      </li>
      <li><a class="nav-link" href="#Handling_events">Handling Events</a></li>
      <li><a class="nav-link" href="#Conditional_rendering">Conditional rendering</a></li>
      <li><a class="nav-link" href="#Lists_and_keys">Lists and Keys</a></li>
      <li>
        <a class="nav-link" href="#Forms">Forms</a>
      </li>
      <li><a class="nav-link" href="#lifting_state_up">Lifting state up</a></li>
      <li>
        <a class="nav-link" href="#composition_vs_inheritance"
          >Composition vs inheritance</a
        >
      </li>
      <li><a class="nav-link" href="#thinking_in_react"> Thinking in React</a></li>
      <li><a class="nav-link" href="#Reference">Reference</a></li>
      
    </ul>
  </nav>
  <main id="main-doc">
    <section class="main-section" id="Helloworld">
      <header> <b> Hello world </b></header>
      <article>
        <p>The smallest React example looks like this:
        </p>
        <code class="code"
          >ReactDOM.render( Hello, world!, document.getElementById('root') );
        </code>
        <p>It displays a heading saying “Hello, world!” on the page.
        </p>
        <P> <b> Knowledge Level Assumptions </b> <br>
            React is a JavaScript library, and so we’ll assume you have a basic understanding of the JavaScript language.
             If you don’t feel very confident, we recommend going through a JavaScript tutorial to check your knowledge
              level and enable you to follow along this guide without getting lost. It might take you between 30 minutes and an hour,
             but as a result you won’t have to feel like you’re learning both React and JavaScript at the same time.</P>
        <ul>
          <li>This guide occasionally uses some newer JavaScript syntax in the examples.
               If you haven’t worked with JavaScript in the last few years, 
               these three points should get you most of the way.


          </li>
          <li>This guide is designed for people who prefer learning concepts step by step. 
              If you prefer to learn by doing, check out our practical tutorial. 
              You might find this guide and the tutorial complementary to each other.
          </li>
        </ul>
      </article>
    </section>
    <section class="main-section" id="IntroducingJsx">
      <header>Introducing Jsx</header>
      <article>
        <p>Consider this variable declaration:</p>
        <code class="code"> const element = Hello, world!; </code>
  
        <ul>
          <li>
            This funny tag syntax is neither a string nor HTML.
          </li>
          <li>This  is called JSX, and it is a syntax extension to JavaScript.
               We recommend using it with React to describe what the UI should look like. 
               JSX may remind you of a template language,
               but it comes with the full power of JavaScript.</li>
          <li>
            JSX produces React “elements”. 
            We will explore rendering them to the DOM in the next section.
             Below, you can find the basics of JSX necessary to get you started.

            
          </li>
          <b>Why Jsx?</b>
          <li>React embraces the fact that rendering logic is inherently coupled with other UI logic: 
              how events are handled, how the state changes over time, and how the data is prepared for display.</li>
            <li>
                Instead of artificially separating technologies by putting markup and logic in separate files, 
                React separates concerns with loosely coupled units called “components” that contain both. We will come back to components in a further section, 
                but if you’re not yet comfortable putting markup in JS, this talk might convince you otherwise.
            </li>
            <li>
                React doesn’t require using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code.
                 It also allows React to show more useful error and warning messages
            </li>

        </ul>
      </article>
    </section>
    <section class="main-section" id="RenderingElements">
      <header>Rendering Element </header>
      <article>
        <p>
            Elements are the smallest building blocks of React apps.
            <i>An element describes what you want to see on the screen:</i>
        </p>
        <code class="code"> const element = Hello, world;  </code>
        <p>
            Unlike browser DOM elements, React elements are plain objects, and are cheap to create. 
            React DOM takes care of updating the DOM to match the React elements.
        </p>
        <p>
          <b>Rendering an Element into the DOM</b> </p>
          <code class="code"> opendiv id="root"> closediv </code>
          <p>
            We call this a “root” DOM node because everything inside it will be managed by React DOM.

            Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.
            
            To render a React element into a root DOM node, pass both to ReactDOM.render():
          </p>
          <code class="code">
            const element = Hello, world;
            ReactDOM.render(element, document.getElementById('root'));
          </code>
          <i>It displays “Hello, world” on the page.</i>
          <p>
              <b>Updating the Rendered Element </b> <br>
              React elements are immutable. Once you create an element, 
              you can’t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.

With our knowledge so far, the only way to update the UI is to create a new element,
 and pass it to ReactDOM.render().

Consider this ticking clock example:
          </p>
        <code class="code">
            function tick() {
                const element = (
                  opendiv
                    Hello, world!
                    It is {new Date().toLocaleTimeString()}.
                closediv>
                );
                ReactDOM.render(element, document.getElementById('root'));
              }
              
              setInterval(tick, 1000);
        </code>
        <i>It calls ReactDOM.render() every second from a setInterval() callback</i>
      </article>
    </section>
    <section class="main-section" id="components_and_props">
      <header>Components and Props</header>
      <article>
        Components let you split the UI into independent, reusable pieces, 
        and think about each piece in isolation. This page provides an introduction to the idea of components. 
        You can find a detailed component API reference here.
       
            <i>Conceptually, components are like JavaScript functions.
                 They accept arbitrary inputs (called “props”) and
                 return React elements describing what should appear on the screen.</i>
        <p>
            <b>Function and Class Components</b> <br>
            The simplest way to define a component is to write a JavaScript function:
            
        </p>
        <code class="code">
            function Welcome(props) {
                return  Hello, {props.name};
              }
        </code>
        <p>
            This function is a valid React component because it accepts a single “props” 
            (which stands for properties) object argument with data and returns a React element. 
            We call such components “function components” because they are literally JavaScript functions.

You can also use an ES6 class to define a component:
        </p>
        <code class="code">
            class Welcome extends React.Component {
                render() {
                  return Hello, {this.props.name};
                }
              }
        </code>
        <i>The above two components are equivalent from React’s point of view.

            Function and Class components both have some additional</i>
      </article>
    </section>
    <section class="main-section" id="State_and_life_cycle">
      <header> State and Life Cycle </header>
      <p><cite>This page introduces the concept of state and lifecycle in a React component. 
          You can find a detailed component API reference here.

        Consider the ticking clock example from one of the previous sections.
         In Rendering Elements, we have only learned one way to update the UI. We call ReactDOM.render() 
        to change the rendered output:</cite>
      </p>
      <code class="code">
        function tick() {
            const element = (
              opendiv
                Hello, world!
                It is {new Date().toLocaleTimeString()}.
              closediv
            );
            ReactDOM.render(
              element,
              document.getElementById('root')
            );
          }
          
          setInterval(tick, 1000);
      </code>
      
    </section>
    <section class="main-section" id="Handling_events">
      <header>Handling Events</header>
      <article>
        Handling events with React elements is very similar to handling events on DOM elements. 
        There are some syntax differences:
        <ul>
            <li>
                React events are named using camelCase, rather than lowercase.
            </li>
            <li>
                With JSX you pass a function as the event handler, rather than a string.
            </li>
        </ul>
        <p>For example, the HTML:
        </p>
        <code class="code">
            button onclick="activateLasers()">
                Activate Lasers
              button
        </code>
        
      </article>
    </section>
    <section class="main-section" id="Conditional_rendering">
      <header>Conditional Rendering</header>
      <article>
        <p>
            In React, you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.

            Conditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like if or the conditional operator to create elements representing the current state, and let React update the UI to match them.
            
            Consider these two components:
        </p>
          <code class="code">function UserGreeting(props) {
            return Welcome back!;
          }
          
          function GuestGreeting(props) {
            return  Please sign up.;
          }</code>
        <p>
            We’ll create a Greeting component that displays 
            either of these components depending on whether a user is logged in:
        </p>
  
        <code class="code"
          >function Greeting(props) {
            const isLoggedIn = props.isLoggedIn;
            if (isLoggedIn) {
              return <UserGreeting />;
            }
            return <GuestGreeting />;
          }
          
          ReactDOM.render(
            // Try changing to isLoggedIn={true}:
            <Greeting isLoggedIn={false} />,
            document.getElementById('root')
          );</code
        >
        <i>This example renders a different greeting depending on the value of isLoggedIn prop.

        </i>
      </article>
    </section>
    <section class="main-section" id="Lists_and_keys">
      <header>Lists and Keys </header>
      <article>
        <p>
            First, let’s review how you transform lists in JavaScript.

            Given the code below, we use the map() function to take an array of numbers and double their values.
             We assign the new array returned by map() to the variable doubled and log it:
        </p>
        <code class="code">
            const numbers = [1, 2, 3, 4, 5];
            const doubled = numbers.map((number) => number * 2);
            console.log(doubled);
        </code>
        <p>
            This code logs [2, 4, 6, 8, 10] to the console.

            In React, transforming arrays into lists of elements is nearly identical.


        </p>
      </article>
    </section>
    <section class="main-section" id="Forms">
      <header>Forms</header>
      <article>
        <p>
            HTML form elements work a bit differently from other DOM elements in React, 
            because form elements naturally keep some internal state. For example, 
            this form in plain HTML accepts a single name:
  
        <code class="code">
            --form>
                --label>
                  Name:
                  --input type="text" name="name" />
                --label>
                input type="submit" value="Submit" />
              --form>
        </code>
        <p>
            This form has the default HTML form behavior of browsing to a new page when the user submits the form.
             If you want this behavior in React, it just works. But in most cases, it’s convenient to have a 
             JavaScript function that handles the submission of the form and has access to the data that the 
             user entered into the form.
             The standard way to achieve this is with a technique called “controlled components”.
        </p>
  
        <p> <b>
            Controlled Components
        </b> 
        </p>
        <ul>
            <li>
                In HTML, form elements such as input, textarea, and select typically maintain their 
                    own state and update it based on user input. In React, mutable state is typically kept in 
                    the state property of components, 
                    and only updated with setState().
            </li>
            <li>
                We can combine the two by making the React state be the “single source of truth”. Then the React component that renders a form also controls what happens in that form on subsequent user input. 
                An input form element whose value is controlled by React in this way is called a “controlled component”
            </li>
        </ul>
  
        <p>
            For example, if we want to make the previous example log the name when it is submitted, 
            we can write the form as a controlled component:
        </p>
  
        <code class="code"
          >}class NameForm extends React.Component {
            constructor(props) {
              super(props);
              this.state = {value: ''};
          
              this.handleChange = this.handleChange.bind(this);
              this.handleSubmit = this.handleSubmit.bind(this);
            }
          
            handleChange(event) {
              this.setState({value: event.target.value});
            }
          
            handleSubmit(event) {
              alert('A name was submitted: ' + this.state.value);
              event.preventDefault();
            }
          
            render() {
              return (
                --form onSubmit={this.handleSubmit}>
                  --label>
                    Name:
                    --input type="text" value={this.state.value} onChange={this.handleChange} />
                  --/label>
                  -input type="submit" value="Submit" />
                --/form>
              );
            }
          }
          </code
        >Since the value attribute is set on our form element, the displayed value will always be this.state.value, making the React state the source of truth. Since handleChange runs on every keystroke to update the React state, the displayed value will update as the user types.

        With a controlled component, the input’s value is always driven by the React state. While this means you have to type a bit more code, you can now pass the value to other UI elements too, or reset it from other event handlers.
        
      </article>
    </section>
    <section class="main-section" id="lifting_state_up">
      <header>Lifting state up </header>
      <article>
        <p>Often, several components need to reflect the same changing data. 
            We recommend lifting the shared state up to their closest common ancestor. 
            Let’s see how this works in action.</p>
        <ul>
          <li>
            <p>In this section, we will create a temperature calculator that calculates whether the water would boil at a given temperature.</p>
            <ul>
              <li><p>We will start with a component called BoilingVerdict. It accepts the celsius temperature as a prop,
                   and prints whether it is enough to boil the water:</p></li>
              
        </ul>
        <code class="code">
            function BoilingVerdict(props) {
                if (props.celsius >= 100) {
                  return The water would boil.;
                }
                return The water would not boil.;
              }
        </code>
        Next, we will create a component called Calculator. It renders an input that lets you enter the temperature, and keeps its value in this.state.temperature.

Additionally, it renders the BoilingVerdict for the current input value.

        <code class="code">
            class Calculator extends React.Component {
                constructor(props) {
                  super(props);
                  this.handleChange = this.handleChange.bind(this);
                  this.state = {temperature: ''};
                }
              
                handleChange(e) {
                  this.setState({temperature: e.target.value});
                }
              
                render() {
                  const temperature = this.state.temperature;
                  return (
                    --fieldset>
                      --legend>Enter temperature in Celsius:--legend>
                      --input
                        value={temperature}
                        onChange={this.handleChange} />
                      -BoilingVerdict
                        celsius={parseFloat(temperature)} />
                    --fieldset>
                  );
                }
              }
        </code>
      </article>
    </section>
    <section class="main-section" id="composition_vs_inheritance">
      <header> Composition vs Inheritance</header>
      <article>
        React has a powerful composition model, and we recommend using composition instead of inheritance to reuse code between components.

In this section, we will consider a few problems where developers new to React often reach for inheritance, and show how we can solve them with composition.
  
        <p>
            <b>
                Containment
            </b> <br>
            Some components don’t know their children ahead of time. This is especially common for components like Sidebar or Dialog that represent generic “boxes”.

We recommend that such components use the special children prop to pass children elements directly into their output
        </p>
  
        <code class="code">
        function FancyBorder(props) {
            return (
              --div className={'FancyBorder FancyBorder-' + props.color}>
                {props.children}
              --div>
            );
          }</code>
        
          This lets other components pass arbitrary children to them by nesting the JSX:
        <code class="code">function WelcomeDialog() {
            return (
              -FancyBorder color="blue">
                -h1 className="Dialog-title">
                  Welcome
                -h1>
                -p className="Dialog-message">
                  Thank you for visiting our spacecraft!
                -p>
              --FancyBorder>
            );
          }</code> 
          <p>
            Anything inside the FancyBorder JSX tag gets passed into the FancyBorder component as a children prop.
                 Since FancyBorder renders {props.children} inside a div, the passed elements appear in the final output.

                While this is less common, sometimes you might need multiple “holes” in a component. 
                In such cases you may come up with your own convention instead of using children:
          </p>
  
        <code class="code">function SplitPane(props) {
            return (
              --div className="SplitPane">
                -div className="SplitPane-left">
                  {props.left}
                --div>
                --div className="SplitPane-right">
                  {props.right}
                --div>
              --div>
            );
          }
          
          function App() {
            return (
              -SplitPane
                left={
                  -Contacts />
                }
                right={
                  --Chat />
                } />
            );
          }</code>

          <i>
            React elements like Contacts and Chat are just objects, so you can pass them as props like any other data. This approach may remind you of “slots” in other
             libraries but there are no limitations on what you can pass as props in React.
          </i>
      </article>
    </section>
    <section class="main-section" id="thinking_in_react">
      <header>Thinking in React</header>
      <article>
       <p>
        React is, in our opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram.

        One of the many great parts of React is how it makes you think about apps as you build them. In this document, 
        we’ll walk you through the thought process of building a searchable product data table using React.
       </p>
  
        <p>
            Start With A Mock
        </p>
  
        <code class="code">
            [
  {category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},
  {category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},
  {category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},
  {category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},
  {category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},
  {category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}
];
        </code>
        <p>
            <b>
                Break The UI Into A Component Hierarchy
            </b>
        </p>
        <ul>
            <li>
                <p>
                    The first thing you’ll want to do is to draw boxes around every component (and subcomponent) in the mock and give them all names. If you’re working with a designer, they may have already done this, 
                    so go talk to them! Their Photoshop layer names may end up being the names of your React components!
                </p>
            </li>
            <li>
                <p>
                    But how do you know what should be its own component? Use the same techniques for deciding if you should create a new function or object. One such technique is the single responsibility principle, that is, a component should ideally only do one thing. If it ends up growing, 
                    it should be decomposed into smaller subcomponents.
                </p>
            </li>
            <li>
                  <p>
                    Since you’re often displaying a JSON data model to a user, you’ll find that if your model was built correctly, your UI (and therefore your component structure) will map nicely. That’s because UI and data models tend to adhere to the same information architecture. 
                    Separate your UI into components, where each component matches one piece of your data model.
                  </p>  
            </li>

        </ul>
        <p>
            You’ll see here that we have five components in our app. We’ve italicized the data each component represents.
        </p>

        <ol>
            <li>
                FilterableProductTable (orange): contains the entirety of the example
            </li>
            <li>
                SearchBar (blue): receives all user input
            </li>
            <li>
                ProductTable (green): displays and filters the data collection based on user input
            </li>
            <li>
                ProductCategoryRow (turquoise): displays a heading for each category
            </li>
            <li>
                ProductRow (red): displays a row for each product
            </li>
        </ol>
        <p>
            If you look at ProductTable, you’ll see that the table header (containing the “Name” and “Price” labels) isn’t its own component. This is a matter of preference, and there’s an argument to be made either way. For this example, we left it as part of ProductTable because it is part of rendering the data collection which is ProductTable’s responsibility. However, if this header grows to be complex (e.g., if we were to add affordances for sorting),
             it would certainly make sense to make this its own ProductTableHeader component.
        </p>
      </article>
    </section>
    <section class="main-section" id="Reference">
      <header>Reference</header>
      <article>
        <ul>
          <li>
            All the documentation in this page is taken from
            <a
              href="https://https://reactjs.org/docs/"
              target="_blank"
              >reactjs </a
            >
            <p><i>check full documentation! Asap</i></p>
          </li>
        </ul>
      </article>
    </section>
  </main>
  
    
</body>
</html>